<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>秋河落叶</title><link>https://blog.poneding.com/algo/</link><description>Recent content on 秋河落叶</description><generator>Hugo</generator><language>cn</language><atom:link href="https://blog.poneding.com/algo/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://blog.poneding.com/algo/%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/algo/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>🏠 首页 / 数据结构与算法 / 堆排序
堆排序 # 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为 O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。
堆 # 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。：
算法实现（golang） # package main import &amp;#34;fmt&amp;#34; type BinaryTreeNode struct { Value int Left, Right *BinaryTreeNode } func main() { tree := &amp;amp;BinaryTreeNode{ Left: &amp;amp;BinaryTreeNode{ Left: &amp;amp;BinaryTreeNode{ Value: 1, }, Right: &amp;amp;BinaryTreeNode{ Value: 2, }, Value: 3, }, Right: &amp;amp;BinaryTreeNode{ Value: 4, }, Value: 5, } res := HeapSort(tree) fmt.Println(res) } func HeapSort(tree *BinaryTreeNode) []int { var res []int if tree == nil { return []int{} } res = heapSortHelper(tree, res) return res } func heapSortHelper(tree *BinaryTreeNode, res []int) []int { if tree.</description></item><item><title/><link>https://blog.poneding.com/algo/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/algo/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>🏠 首页 / 数据结构与算法 / 快速排序
快速排序 # 步骤如下：
先从数列中取出一个数作为基准数。一般取第一个数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。 举一个例子：5 9 1 6 8 14 6 49 25 4 6 3。
一般取第一个数 5 作为基准，从它左边和最后一个数使用[]进行标志， 如果左边的数比基准数大，那么该数要往右边扔，也就是两个[]数交换，这样大于它的数就在右边了，然后右边[]数左移，否则左边[]数右移。 5 [9] 1 6 8 14 6 49 25 4 6 [3] 因为 9 &amp;gt; 5，两个[]交换位置后，右边[]左移 5 [3] 1 6 8 14 6 49 25 4 [6] 9 因为 3 !&amp;gt; 5，两个[]不需要交换，左边[]右移 5 3 [1] 6 8 14 6 49 25 4 [6] 9 因为 1 !</description></item></channel></rss>