<!doctype html><html lang=cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="🏠 首页 / Kubernetes / 了解 Volume
了解 Volume # 我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。
在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 Volume 的概念来满足这种需求。
Volume 介绍 # 在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。
在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。
容器与 Volume 的简单关系：
Volume 定义 # 定义在 pod.spec.container 属性下：
kind: Pod ... spec: container: ... volumeMounts: - mountPath: <path> name: <volume-name> subPath: <volume-path> volumes: - name: <volume-name> <volume-type>: ... mountPath： 容器内的目录，如果不存在则创建该目录 subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。 Volume 类型 # Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考： https://kubernetes."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://blog.poneding.com/kubernetes/volume-understood/"><meta property="og:site_name" content="秋河落叶"><meta property="og:title" content="秋河落叶"><meta property="og:description" content="🏠 首页 / Kubernetes / 了解 Volume
了解 Volume # 我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。
在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 Volume 的概念来满足这种需求。
Volume 介绍 # 在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。
在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。
容器与 Volume 的简单关系：
Volume 定义 # 定义在 pod.spec.container 属性下：
kind: Pod ... spec: container: ... volumeMounts: - mountPath: <path> name: <volume-name> subPath: <volume-path> volumes: - name: <volume-name> <volume-type>: ... mountPath： 容器内的目录，如果不存在则创建该目录 subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。 Volume 类型 # Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考： https://kubernetes."><meta property="og:locale" content="cn"><meta property="og:type" content="article"><meta property="article:section" content="kubernetes"><meta property="article:modified_time" content="2024-06-13T15:37:18+08:00"><title>Volume Understood | 秋河落叶</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/logo.png><link rel=canonical href=https://blog.poneding.com/kubernetes/volume-understood/><link rel=stylesheet href=/book.min.4964903a822a7acb10dac6d1ab524833c97fb5f99b141976bcb8a47d539be9c0.css integrity="sha256-SWSQOoIqessQ2sbRq1JIM8l/tfmbFBl2vLikfVOb6cA=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/cn.search.min.579b6e670fb68946e256880a10805e536c7e20972888d5c3a67d0b64e6384e29.js integrity="sha256-V5tuZw+2iUbiVogKEIBeU2x+IJcoiNXDpn0LZOY4Tik=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><link rel=stylesheet href=/css/syntax.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo><span>秋河落叶</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><p>🦉 集中起来的意志可以击穿顽石。</p><hr><ul><li><p><a href=/><strong>🏠 首页</strong></a></p></li><li><p><strong>📌 置顶文章</strong></p><ul><li><a href=/git/common-usage/>Git 常用</a></li><li><a href=/kubernetes/kubeadm-install-k8s-docker/>安装 Kubernetes (Docker)</a></li></ul></li><li><p><strong>📌 置顶分类</strong></p><ul><li><a href=/go/>Golang 编程</a></li><li><a href=/kubernetes/>Kubernetes</a></li><li><a href=/rust/>Rust 编程</a></li><li><a href=/git/>Git</a></li></ul></li></ul><hr><ul><li><strong>🗃️ 开源项目</strong><ul><li><a href=https://github.com/ketches/registry-proxy>registry-proxy</a></li><li><a href=https://github.com/poneding/mdi>mdi</a></li></ul></li></ul><hr><ul><li><a href=https://github.com/poneding target=_blank rel=noopener>🐙 GitHub</a></li><li><a href=mailto:poneding@gmail.com target=_blank rel=noopener>📬 邮箱</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Volume Understood</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#volume-介绍>Volume 介绍</a></li><li><a href=#volume-定义>Volume 定义</a></li><li><a href=#volume-类型>Volume 类型</a><ul><li><a href=#emptydir>emptyDir</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#configmap>configMap</a></li><li><a href=#secret>Secret</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p><a href=/>🏠 首页</a> /
<a href=/kubernetes/>Kubernetes</a> / 了解 Volume</p><h1 id=了解-volume>了解 Volume
<a class=anchor href=#%e4%ba%86%e8%a7%a3-volume>#</a></h1><p>我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。</p><p>在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 <code>Volume</code> 的概念来满足这种需求。</p><h2 id=volume-介绍>Volume 介绍
<a class=anchor href=#volume-%e4%bb%8b%e7%bb%8d>#</a></h2><p>在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。</p><p>在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。</p><p>容器与 Volume 的简单关系：</p><p><img src=https://fs.poneding.com/images/image-20200623123450872.png alt=image-20200623123450872></p><h2 id=volume-定义>Volume 定义
<a class=anchor href=#volume-%e5%ae%9a%e4%b9%89>#</a></h2><p>定义在 <code>pod.spec.container</code> 属性下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>container</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>&lt;path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>&lt;volume-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>subPath</span><span class=p>:</span><span class=w> </span><span class=l>&lt;volume-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>&lt;volume-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>&lt;volume-type&gt;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><ul><li>mountPath： 容器内的目录，如果不存在则创建该目录</li><li>subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。</li></ul><h2 id=volume-类型>Volume 类型
<a class=anchor href=#volume-%e7%b1%bb%e5%9e%8b>#</a></h2><p>Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考：
<a href=https://kubernetes.io/zh/docs/concepts/storage/volumes>https://kubernetes.io/zh/docs/concepts/storage/volumes</a></p><h3 id=emptydir>emptyDir
<a class=anchor href=#emptydir>#</a></h3><p>如果指定 Volume 类型为 emptyDir，它会在 Pod 刚被调度时，在被调度到的节点上创建起来。卷初始时时空的，里面没有文件，Pod 内的容器可以在卷中写入文件。多个容器绑定的 Volume 如果存在目录相同，则目录可以被共享读写。</p><p>如果 Pod 在该节点被销毁，那么 emptyDir 也将被永久删除。Pod 内的容器崩溃或重启是不会影响 emptyDir 的生命周期的。</p><p>由于 emptyDir 的生命周期受Pod影响，emptyDir 适合的使用场景也会受限，emptyDir 适合使用在数据临时计算，临时缓存等，不适合存储配置信息或持久化数据。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/shareDir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/shareDir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></span></span></code></pre></div><p>如果在 K8s 中创建上面这个 Pod，容器都运行起来后，分别进入 nginx 容器和 redis 容器，都可以在根目录下看到 <code>shareDir</code> 目录，并且在一个容器中写入了文件，另一个容器也可以读取到。当删除这个 Pod，再重新创建后，之前写入的文件会消失。</p><p>emptyDir 可以指定存储介质，默认是使用节点的磁盘创建起来的，也可以指定介质为内存，这种读写更快：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>medium</span><span class=p>:</span><span class=w> </span><span class=l>Memory</span><span class=w>
</span></span></span></code></pre></div><h3 id=hostpath>hostPath
<a class=anchor href=#hostpath>#</a></h3><p>hostPath 卷指向节点文件系统上的特定文件或目录，如果多个 Pod 运行在同一节点，并且指向相同的卷路径，则他们看的文件是相同的。</p><p><img src=https://fs.poneding.com/images/image-20200623145055913.png alt=image-20200623145055913></p><p>hostPath 类型的 Volume 的生命周期不受Pod限制，Pod 被删除，hostPath 下的文件仍然保留。由于 hostPath 数据只会保留在节点上，当 Pod 被重新调度到其他节点时，相对来说数据是丢失的。一般可以使用 hostPath 作为 DaemonSet（每个匹配节点都调度一个 Pod）管理的 Pod 的 Volume。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dir</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>hostPath</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/vol/redis/data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>DirectoryOrCreate</span><span class=w>
</span></span></span></code></pre></div><p>当我们创建以上 Pod 资源，容器运行起来之后，则会在 Pod 所调度的宿主机上创建 <code>/vol/redis/data</code> 目录。如果我们删除Pod，宿主机上的 <code>/vol/redis/data</code> 目录不会被删除。</p><p>hostPath 的 type 类型，默认为空，直接使用 path，其他 type 使用时会检查和初始化 path：</p><ul><li>DirectoryOrCreate，如果 hostPath 定义的 path 目录不存在，则创建目录</li><li>Directory，hostPath 定义的 path 目录已经存在，否则会异常</li><li>FileOrCreate，如果 hostPath 定义 的path 文件不存在，则创建文件，如果前缀目录不存在也会报错，需要先使用 DirectoryOrCreate 创建目录</li><li>File，hostPath 定义的 path 文件已经存在，否则会异常</li></ul><h3 id=persistentvolumeclaim>persistentVolumeClaim
<a class=anchor href=#persistentvolumeclaim>#</a></h3><h3 id=awselasticblockstore>awsElasticBlockStore
<a class=anchor href=#awselasticblockstore>#</a></h3><p>使用 aws 的存储卷作为 Pod 的 Volume，它可以被多个 Pod 共同使用，并且它的生命周期不受 Pod 限制，当 Pod 被销毁，只是取消了绑定关系，存储不会被删除。</p><p>使用 awsElasticBlockStore 作为 Volume，需要提前在 aws 中创 volume，获取到 volumeID，然后 Pod 的 Volume 指定awsElasticBlockStore 的 volumeID 即可。</p><p>使用 aws-cli 创建 aws 中的 volume：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>aws ec2 create-volume --availability-zone<span class=o>=</span>ap-southeast-1a --size<span class=o>=</span><span class=m>2</span> --volume-type<span class=o>=</span>gp2
</span></span></code></pre></div><p>以上命令完成会输出 volumeID。</p><p>使用 awsElasticBlockStore 作为 Pod 的 Volume 简单示例，前提我们已经获取到 了volumeID 为 vol-07afc8d24f8f08d2a：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>awsElasticBlockStore</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumeID</span><span class=p>:</span><span class=w> </span><span class=l>vol-07afc8d24f8f08d2a</span><span class=w>
</span></span></span></code></pre></div><p>当我们创建以上 Pod 资源，容器运行起来之后，我们进入 redis 容器，使用 redis-cli往redis 中写入一个key-value后，立即退出容器，删除 Pod 并重新创建后，再次进入容器，是依然可以获取 key-value 的，这说明 Volume 数据没有随 Pod 被删除。</p><h3 id=configmap>configMap
<a class=anchor href=#configmap>#</a></h3><p>存储配置项信息，供 Volume 使用，后续可能会单独介绍它的使用。</p><h3 id=secret>Secret
<a class=anchor href=#secret>#</a></h3><p>存储敏感信息的配置，供 Volume 使用，后续可能会单独介绍它的使用。</p><hr><p><a href=/kubernetes/velero-minio-backup-restore-volume/>« Velero + Minio 备份与恢复</a></p><p><a href=/kubernetes/vpa/>» VPA</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/poneding/blog/commit/5faa4f1be5d4525c49e513962394eae7c15fb6f2 title='最后修改者 poneding | 2024/06/13' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2024/06/13</span></a></div><div><a class="flex align-center" href=https://github.com/poneding/blog/edit/master/content/kubernetes/volume-understood.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=poneding/blog data-repo-id=R_kgDOMITIHg data-category=General data-category-id=DIC_kwDOMITIHs4CgB4x data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#volume-介绍>Volume 介绍</a></li><li><a href=#volume-定义>Volume 定义</a></li><li><a href=#volume-类型>Volume 类型</a><ul><li><a href=#emptydir>emptyDir</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#configmap>configMap</a></li><li><a href=#secret>Secret</a></li></ul></li></ul></nav></div></aside></main></body></html>