<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>秋河落叶</title><link>https://blog.poneding.com/go/</link><description>Recent content on 秋河落叶</description><generator>Hugo</generator><language>cn</language><atom:link href="https://blog.poneding.com/go/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://blog.poneding.com/go/dev-env-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/dev-env-config/</guid><description>🏠 首页 / Golang 编程 / Go 开发环境配置
Go 开发环境配置 # cobra-cli # 安装：
go install github.com/spf13/cobra-cli@latest 自动补全：
cobra-cli completion zsh &amp;gt; .zfunc/_cobra-cli 在 .zshrc 文件中添加内容（如果已添加，则忽略）：
fpath+=~/.zfunc autoload -Uz compinit &amp;amp;&amp;amp; compinit » Golang 函数可选参数模式</description></item><item><title/><link>https://blog.poneding.com/go/function-optional-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/function-optional-pattern/</guid><description>🏠 首页 / Golang 编程 / Golang 函数可选参数模式
Golang 函数可选参数模式 # 函数可选参数模式 # type Server struct { Addr string Timeout time.Duration } type Option func(*Server) func newServer(addr string, options ...Option) (*Server, error) { s := &amp;amp;Server{ Addr: addr, } for _, opt := range options { opt(s) } // ... return s, nil } func WithTimeout(timeout time.Duration) Option { return func(s *Server) { s.Timeout = timeout } } 通用函数可选参数模式 # type BasicService struct { redisClient string } type ServiceOption func(*BasicService) func WithRedisClient(redisClient string) ServiceOption { return func(s *BasicService) { s.</description></item><item><title/><link>https://blog.poneding.com/go/go-cert-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-cert-management/</guid><description>🏠 首页 / Golang 编程 / Golang 密钥对、数字签名和证书管理
Golang 密钥对、数字签名和证书管理 # Golang 实现密钥对生成 相当于使用 openssl 生成私钥和公钥：
openssl genrsa -out pri.key 2048 openssl rsa -in pri.key -pubout -out pub.key package main import ( &amp;#34;crypto/rand&amp;#34; &amp;#34;crypto/rsa&amp;#34; ) func GenerateKeyPair() (*rsa.PrivateKey, *rsa.PublicKey, error) { prikey, err := rsa.GenerateKey(rand.Reader, 2048) if err != nil { return nil, nil, err } return prikey, &amp;amp;prikey.PublicKey, nil } 实现加密和解密 加密解密：公钥加密，私钥解密
package main import ( &amp;#34;crypto/rand&amp;#34; &amp;#34;crypto/rsa&amp;#34; ) func Encrypt(data []byte, publicKey *rsa.</description></item><item><title/><link>https://blog.poneding.com/go/go-cross-complie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-cross-complie/</guid><description>🏠 首页 / Golang 编程 / Golang 不同平台架构编译
Golang 不同平台架构编译 # 在 MacOS 平台编译成 Windows、Linux 可执行文件：
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go 在 Windows 平台编译成 Linux、MacOS 可执行文件：
$env:GOOS = &amp;#34;linux&amp;#34;;$env:CGO_ENABLED = &amp;#34;0&amp;#34;;$env:GOARCH = &amp;#34;amd64&amp;#34;;go build carbon/carbon.go $env:GOOS = &amp;#34;linux&amp;#34;;$env:CGO_ENABLED = &amp;#34;0&amp;#34;;$env:GOARCH = &amp;#34;arm64&amp;#34;;go build carbon/carbon.go $env:GOOS = &amp;#34;darwin&amp;#34;;$env:CGO_ENABLED = &amp;#34;0&amp;#34;;$env:GOARCH = &amp;#34;amd64&amp;#34;;go build carbon/carbon.</description></item><item><title/><link>https://blog.poneding.com/go/go-gen-cert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-gen-cert/</guid><description>🏠 首页 / Golang 编程 / Golang 生成证书
Golang 生成证书 # 代码实现 # package certutil import ( &amp;#34;bytes&amp;#34; &amp;#34;crypto/rand&amp;#34; &amp;#34;crypto/rsa&amp;#34; &amp;#34;crypto/x509&amp;#34; &amp;#34;crypto/x509/pkix&amp;#34; &amp;#34;encoding/pem&amp;#34; &amp;#34;math/big&amp;#34; &amp;#34;net&amp;#34; &amp;#34;time&amp;#34; ) // CA ca type CA struct { caInfo *x509.Certificate caPrivKey *rsa.PrivateKey caPem, caKeyPem []byte } // GetCAPem get ca pem bytes func (c *CA) GetCAPem() ([]byte, error) { if c.caPem == nil { // create the CA caBytes, err := x509.CreateCertificate(rand.Reader, c.caInfo, c.</description></item><item><title/><link>https://blog.poneding.com/go/go-linkname/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-linkname/</guid><description>🏠 首页 / Golang 编程 / go:linkname 指令
go:linkname 指令 # 背景 # 阅读 Golang 源码时，发现在标准库 time.Sleep 方法没有没有方法体。如下：
// Sleep pauses the current goroutine for at least the duration d. // A negative or zero duration causes Sleep to return immediately. func Sleep(d Duration) 当我们直接在代码中写一个空方法 func Foo()，编译时会报错：missing function body。所以标准库使用了什么魔法来实现空方法的呢？ 进一步研究，得知 time.Sleep 运行时实际调用了 runtime.timeSleep方法，如下：
// timeSleep puts the current goroutine to sleep for at least ns nanoseconds. // //go:linkname timeSleep time.</description></item><item><title/><link>https://blog.poneding.com/go/go-list-to-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-list-to-tree/</guid><description>🏠 首页 / Golang 编程 / Golang 列表转树
Golang 列表转树 # 场景介绍 # 从数据库获取到了菜单列表数据，这些菜单数据通过字段 ParentID 表示父子层级关系，现在需要将菜单列表数据转成树状的实例对象。
数据库取出的初始数据：
raw := []Menu{ {Name: &amp;#34;一级菜单 1&amp;#34;, ID: 1, PID: 0}, {Name: &amp;#34;一级菜单 2&amp;#34;, ID: 2, PID: 0}, {Name: &amp;#34;一级菜单 3&amp;#34;, ID: 3, PID: 0}, {Name: &amp;#34;二级菜单 1-1&amp;#34;, ID: 11, PID: 1}, {Name: &amp;#34;二级菜单 1-2&amp;#34;, ID: 12, PID: 1}, {Name: &amp;#34;二级菜单 1-3&amp;#34;, ID: 13, PID: 1}, {Name: &amp;#34;二级菜单 2-1&amp;#34;, ID: 21, PID: 2}, {Name: &amp;#34;二级菜单 2-2&amp;#34;, ID: 22, PID: 2}, {Name: &amp;#34;二级菜单 2-3&amp;#34;, ID: 23, PID: 2}, } 需要得到的目标数据：</description></item><item><title/><link>https://blog.poneding.com/go/go-mtls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-mtls/</guid><description>🏠 首页 / Golang 编程 / Golang 实现双向认证
Golang 实现双向认证 # TLS # 传输层安全协议（TLS），在互联网上，通常是由服务器单向的向客户端提供证书，以证明其身份。
mTLS # 双向 TLS 认证，是指在客户端和服务器之间使用双行加密通道，mTLS 是云原生应用中常用的通信安全协议。
使用双向TLS连接的主要目的是当服务器应该只接受来自有限的允许的客户端的 TLS 连接时。例如，一个组织希望将服务器的 TLS 连接限制为只来自该组织的合法合作伙伴或客户。显然，为客户端添加IP白名单不是一个好的安全实践，因为IP可能被欺骗。
为了简化 mTLS 握手的过程，我们这样简单梳理：
客户端发送访问服务器上受保护信息的请求； 服务器向客户端提供公钥证书； 客户端通过使用 CA 的公钥来验证服务器公钥证书的数字签名，以验证服务器的证书； 如果步骤 3 成功，客户机将其客户端公钥证书发送到服务器； 服务器使用步骤 3 中相同的方法验证客户机的证书； 如果成功，服务器将对受保护信息的访问权授予客户机。 代码实现 # 需要实现客户端验证服务端的公钥证书，服务端验证客户端的公钥证书。
生成证书 # echo &amp;#39;清理并生成目录&amp;#39; OUT=./certs DAYS=365 RSALEN=2048 CN=poneding rm -rf ${OUT}/* mkdir ${OUT} &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1 cd ${OUT} echo &amp;#39;生成CA的私钥&amp;#39; openssl genrsa -out ca.key ${RSALEN} &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1 echo &amp;#39;生成CA的签名证书&amp;#39; openssl req -new \ -x509 \ -key ca.</description></item><item><title/><link>https://blog.poneding.com/go/go-publish-package-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-publish-package-01/</guid><description>🏠 首页 / Golang 编程 / Golang 发布类库 - 1
Golang 发布类库 - 1 # 本页介绍如何在 Github 上发布我们自己的 Golang 类库。
1、创建 github 仓库托管 go 类库代码，例如 common-go：：
2、将仓库克隆至本地：：
git clone https://github.com/poneding/common-go.git 3、初始化go类库的module：：
cd common-go go mod init github.com/poneding/common-go mkdir hello 注意：
使用 go env 命令查看是否开启 go-module 功能，如果没开启需要设置环境变量：go env -w GO111MODULE=on；
module 名称需要与 github 仓库一致，这样其他人才能通过 go get github.com/poneding/commmon-go 下载到你的类库。
4、编写 go 类库代码，例如：：
hell/hello.go：
package hello import &amp;#34;fmt&amp;#34; func Say(name string) { fmt.</description></item><item><title/><link>https://blog.poneding.com/go/go-publish-package-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-publish-package-02/</guid><description>🏠 首页 / Golang 编程 / Golang 发布类库 - 2
Golang 发布类库 - 2 # 本页介绍如何在 Github 上升级我们已发布的 Golang 类库。
Go 类库版本规则 # go 类库版本的规则：主版本号.次版本号.修订号，其中：
主版本号：类库进行了不可向下兼容的修改，例如功能重构，这时候主版本号往上追加； 次版本号：类库进行了可向下兼容的修改，例如新增功能，这时候次版本号往上追加； 修订号：类库进行了可向下兼容的修改（修改的规模更小），例如修复或优化功能，这时候修订好往上追加。 Go 类库发版示例 # 同样以 github.com/poneding/common-go 类库为示例。
小版本升级 # 主版本不升级，次版本或修订版本升级。
v0.x.x 版本升级至 v1.x.x 也是可以直接升级的。
当前版本是 v1.0.0，现对该类库进行了功能修改，发布 v1.0.1 版本：
1、切换至 v1 分支：
git checkout v1 2、修改类库代码：
hello/hello.go：
package hello import &amp;#34;fmt&amp;#34; func Say(name string) { fmt.Printf(&amp;#34;Hello, %s\n&amp;#34;, name) fmt.Println(&amp;#34;common-go version: v1.0.1&amp;#34;) } 3、提交代码并发布：</description></item><item><title/><link>https://blog.poneding.com/go/go-solid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-solid/</guid><description>🏠 首页 / Golang 编程 / Go 程序 SOLID 设计原则
Go 程序 SOLID 设计原则 # 可重用软件设计的五个原则，SOLID 原则：
单一职责原则（Single Responsibility Principle） 开放 / 封闭原则（Open / Closed Principle） 里氏替换原则（Liskov Substitution Principle） 接口隔离原则（Interface Segregation Principle） 依赖倒置原则（Dependency Inversion Principle） 单一职责原则 # SOLID 的第一个原则，S，是单一责任原则。
A class should have one, and only one, reason to change. – Robert C Martin
现在 Go 显然没有 classses - 相反，我们有更强大的组合概念 - 但是如果你能回顾一下 class 这个词的用法，我认为此时会有一定价值。
为什么一段代码只有一个改变的原因很重要？嗯，就像你自己的代码可能会改变一样令人沮丧，发现您的代码所依赖的代码在您脚下发生变化更痛苦。当你的代码必须改变时，它应该响应直接刺激作出改变，而不应该成为附带损害的受害者。
因此，具有单一责任的代码修改的原因最少。
耦合和内聚 # 描述改变一个软件是多么容易或困难的两个词是：耦合和内聚。</description></item><item><title/><link>https://blog.poneding.com/go/go-stdlib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-stdlib/</guid><description>🏠 首页 / Golang 编程 / Golang 标准库
Golang 标准库 # fmt # 格式化打印
%v 原样输出 %T 打印类型 %t bool %s string %f float %d 10进制整数 %b 2进制整数 %o 8进制整数 %x 16进制整数 0-9，a-f %X 16进制整数 0-9，A-F %c char %p pointer %.2f float 保留两位 path # file := &amp;#34;./logs/2021-01-25/error.log&amp;#34; fileName := path.Base(file) # 返回文件名：error.log fileExt := path.Ext(file) # 返回文件后缀：.log fileDir := path.Dir(file) # 返回文件路径： ./logs/2021-01-25 os/exec # Golang语言有一个包叫做 os/exec，使用该包可以直接在程序中调用主机的命令，使用示例如下：
func OsExecUsage() error { fmt.</description></item><item><title/><link>https://blog.poneding.com/go/go-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go-testing/</guid><description>🏠 首页 / Golang 编程 / testing
testing # 命令 # 测试
go test -run=TestCompare -v . 运行测试，测试函数名称中仅包含 TestCompare 前缀。
列出包内测试文件
go list -f={{.GoTestFiles}} . 列出包外测试文件
go list -f={{.XTestGoFiles}} . 包内测试：测试文件的包名称与被测包一致，可以访问被测包内所有成员，相当于白盒测试；
包外测试：测试文件的包名称与被测包不一致，一般在被测包名称后面添加 _test 后缀，只能访问被测包内公开成员，相当于黑盒测试。
« Golang 标准库
» Golang</description></item><item><title/><link>https://blog.poneding.com/go/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/go/</guid><description>🏠 首页 / Golang 编程 / Golang
Golang # 资料 # Go 安全指南 Go 语言编程规范 Golang channel # golang 实现并发是通过通信共享内存，channel 是 go 语言中goroutine 的通信管道，通过 channel 将值从一个 goroutine 发送到另一个 goroutine。
语法 # 创建 channel：
使用 make() 函数创建：
ch := make(chan int) 默认创建一个无缓存 channel。
发送数据到 channel：
ch &amp;lt;- x 从 channel 读取数据：
x := &amp;lt;-ch 关闭 channel：
使用 close() 函数关闭：
close(ch) 当你的程序不再需要往 channel 中发送数据时，可以关闭 channel。
如果往已经关闭的 channal 发送数据，程序发生异常。
无缓冲 channel # 如果当前没有一个 goroutine 对无缓冲 channel 接收数据，那么无缓冲 channel 会阻止发送数据。</description></item><item><title/><link>https://blog.poneding.com/go/gopkg-errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/gopkg-errors/</guid><description>🏠 首页 / Golang 编程 / gopkg-errors.md
title: Go 包 - errors date: 2022-10-19T14:44:06+08:00 lastmod: 2022-11-03T03:32:31.646Z tags:
Golang gopkg keywords: Golang gopkg errors weight: 1 errors 包为你的 Go 程序提供一种对程序员调试、查看日志更友好的错误处理方式。
Go 程序中传统的错误处理方法：
if err != nil { return err } 递归的向上传递错误，这种方式有一个缺陷：最终处理错误的位置无法获取错误的调用上下文信息。
errors 包以不破坏错误的原始值的方式向错误中的添加调用上下文信息。
获取包 # go get github.com/pkg/errors 错误添加上下文 # The errors.Wrap function returns a new error that adds context to the original error. For example
_, err := ioutil.ReadAll(r) if err !</description></item><item><title/><link>https://blog.poneding.com/go/goreleaser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/goreleaser/</guid><description>🏠 首页 / Golang 编程 / Goreleaser
Goreleaser # Go 程序项目的自动化发布工具，简单的发布命令帮助我们省去大量的重复工作。
安装 # MacOs：
brew install goreleaser/tap/goreleaser 源码编译：
git clone https://github.com/goreleaser/goreleaser cd goreleaser go get ./... go build -o goreleaser . ./goreleaser --version 初始化 # 在go项目下运行以下命令，生成.goreleaser.yml文件：
goreleaser init 生成文件后，自行配置，相信你能看的懂。
验证 .goreleaser.yml # goreleaser check 使用本地环境构建
goreleaser build --single-target 配置 github token # token 必须至少包含 write:package 权限，才能上传到发布资源中。
从github生成token，写入文件：
mkdir ~/.config/goreleaser vim ~/.config/goreleaser/github_token 或者直接在终端导入环境配置：
export GITHUB_TOKEN=&amp;#34;YOUR_GITHUB_TOKEN&amp;#34; 为项目打上 tag # git tag v0.</description></item><item><title/><link>https://blog.poneding.com/go/mac-appl-silicon-cross-compile-cgo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/mac-appl-silicon-cross-compile-cgo/</guid><description>🏠 首页 / Golang 编程 / Mac M1 交叉编译 CGO
Mac M1 交叉编译 CGO # 方法一 # 1、安装依赖
brew tap messense/macos-cross-toolchains brew install x86_64-unknown-linux-gnu brew install aarch64-unknown-linux-gnu 2、添加到 PATH
export PATH=$PATH:/opt/homebrew/Cellar/x86_64-unknown-linux-gnu/11.2.0_1/bin::/opt/homebrew/Cellar/aarch64-unknown-linux-gnu/11.2.0_1/bin 3、编译 CGO 程序
CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=x86_64-unknown-linux-gnu-gcc CXX=x86_64-unknown-linux-gnu-g++ go build CGO_ENABLED=1 GOOS=linux GOARCH=arm64 CC=aarch64-unknown-linux-gnu-gcc CXX=aarch64-unknown-linux-gnu-g++ go build 方法二 # 1、安装依赖
brew install FiloSottile/musl-cross/musl-cross 2、添加到 PATH
export PATH=$PATH:/opt/homebrew/Cellar/musl-cross/0.9.9_1/bin 3、编译 CGO 程序
# -tags=musl 不能省略不然会出现其他错误 CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=x86_64-linux-musl-gcc CXX=x86_64-linux-musl-g++ go build -tags=musl # 如果linux不想安装musl支持 CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=x86_64-linux-musl-gcc CXX=x86_64-linux-musl-g++ CGO_LDFLAGS=&amp;#34;-static&amp;#34; go build -tags=musl CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=x86_64-linux-musl-gcc CGO_LDFLAGS=&amp;#34;-static&amp;#34; go build CGO_ENABLED=1 GOOS=linux GOARCH=arm64 CC=x86_64-linux-musl-gcc CGO_LDFLAGS=&amp;#34;-static&amp;#34; go build 参考 # https://blog.</description></item><item><title/><link>https://blog.poneding.com/go/pprof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/pprof/</guid><description>🏠 首页 / Golang 编程 / pprof
pprof # pprof 是性能调试工具，可以生成类似火焰图、堆栈图，内存分析图等。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; ) // 吃内存 type Eater struct { Name string Buffer [][]int } var e Eater func main() { e = Eater{Name: &amp;#34;eater&amp;#34;} http.HandleFunc(&amp;#34;/go&amp;#34;, goHandler) http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) // 如果不使用默认的 mux（http.DefaultServeMux），可以使用如下方式集成 pprof // mux := http.NewServeMux() // mux.HandleFunc(&amp;#34;/go&amp;#34;, goHandler) // mux.HandleFunc(&amp;#34;/debug/pprof/&amp;#34;, pprof.Index) // mux.HandleFunc(&amp;#34;/debug/pprof/cmdline&amp;#34;, pprof.Cmdline) // mux.HandleFunc(&amp;#34;/debug/pprof/profile&amp;#34;, pprof.Profile) // mux.HandleFunc(&amp;#34;/debug/pprof/symbol&amp;#34;, pprof.</description></item><item><title/><link>https://blog.poneding.com/go/ssh-keygen-with-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.poneding.com/go/ssh-keygen-with-go/</guid><description>🏠 首页 / Golang 编程 / 使用 Go 生成 OpenSSH 兼容的 RSA 密钥对
使用 Go 生成 OpenSSH 兼容的 RSA 密钥对 # 我们可以使用 ssh-keygen 命令生成一对用于 SSH 访问的私钥和公钥。本文将介绍如何使用 Go 生成一对 OpenSSH 兼容的 RSA 密钥对。
以下代码中 GenOpenSSHKeyPair 方法用于生成一对用于 SSH 访问的私钥和公钥。生成的私钥以 PEM 编码，公钥以 OpenSSH authorized_keys 文件中包含的格式进行编码。
package util import ( &amp;#34;crypto/rand&amp;#34; &amp;#34;crypto/rsa&amp;#34; &amp;#34;crypto/x509&amp;#34; &amp;#34;encoding/pem&amp;#34; &amp;#34;golang.org/x/crypto/ssh&amp;#34; ) // GenOpenSSHKeyPair make a pair of private and public keys for SSH access. // Private Key generated is PEM encoded // Public key is encoded in the format for inclusion in an OpenSSH authorized_keys file.</description></item></channel></rss>