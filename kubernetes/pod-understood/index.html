<!doctype html><html lang=cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="🏠 首页 / Kubernetes / Kubernetes 0-1 了解 Pod
Kubernetes 0-1 了解 Pod # Pod 介绍 # Pod，是 K8s 对象模型中的最小单元，Pod 里面包含着一组容器（单个容器或多个紧密耦合的容器），这时候 Pod 可以理解为一个机器，而 Pod 里面的容器则理解为该机器里面的进程。
Pod 的容器运行时由容器引擎提供，默认的容器引擎是 Docker；并且 K8s 管理的是 Pod，而不是容器。
一个 Pod 内部的容器共享：
存储：一个 Pod 可以指定一组共享存储卷。 网络：每个 Pod 分配一个唯一 IP（集群内 IP），共享网络命名空间，包括 IP 地址和网络端口。Pod 内的容器可以使用 localhost 互相通信，集群内 Pod 与 Pod通信可以使用 Pod 分配的 IP，但是由于 Pod 的 IP 是随机分配的，这种互通信的方式不太适合使用。 尽管一个 Pod 内可以包含多个 Pod，但我们在部署应用容器时的最佳实践是一个 Pod 里面只包含一个应用容器作为主容器，其他容器为主容器服务，称之为辅助容器。例如主容器崩溃了，会有一个辅助容器去重启主容器。辅助容器可以有也可以没有，因为 Pod 里面容器的生命周期可以被 Pod 的生命周期取代，而 Pod 的生命周期可以通过 Pod 管理器来管理维护。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://blog.poneding.com/kubernetes/pod-understood/"><meta property="og:site_name" content="秋河落叶"><meta property="og:title" content="秋河落叶"><meta property="og:description" content="🏠 首页 / Kubernetes / Kubernetes 0-1 了解 Pod
Kubernetes 0-1 了解 Pod # Pod 介绍 # Pod，是 K8s 对象模型中的最小单元，Pod 里面包含着一组容器（单个容器或多个紧密耦合的容器），这时候 Pod 可以理解为一个机器，而 Pod 里面的容器则理解为该机器里面的进程。
Pod 的容器运行时由容器引擎提供，默认的容器引擎是 Docker；并且 K8s 管理的是 Pod，而不是容器。
一个 Pod 内部的容器共享：
存储：一个 Pod 可以指定一组共享存储卷。 网络：每个 Pod 分配一个唯一 IP（集群内 IP），共享网络命名空间，包括 IP 地址和网络端口。Pod 内的容器可以使用 localhost 互相通信，集群内 Pod 与 Pod通信可以使用 Pod 分配的 IP，但是由于 Pod 的 IP 是随机分配的，这种互通信的方式不太适合使用。 尽管一个 Pod 内可以包含多个 Pod，但我们在部署应用容器时的最佳实践是一个 Pod 里面只包含一个应用容器作为主容器，其他容器为主容器服务，称之为辅助容器。例如主容器崩溃了，会有一个辅助容器去重启主容器。辅助容器可以有也可以没有，因为 Pod 里面容器的生命周期可以被 Pod 的生命周期取代，而 Pod 的生命周期可以通过 Pod 管理器来管理维护。"><meta property="og:locale" content="cn"><meta property="og:type" content="article"><meta property="article:section" content="kubernetes"><meta property="article:modified_time" content="2024-06-13T15:37:18+08:00"><title>Pod Understood | 秋河落叶</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/logo.png><link rel=canonical href=https://blog.poneding.com/kubernetes/pod-understood/><link rel=stylesheet href=/book.min.4964903a822a7acb10dac6d1ab524833c97fb5f99b141976bcb8a47d539be9c0.css integrity="sha256-SWSQOoIqessQ2sbRq1JIM8l/tfmbFBl2vLikfVOb6cA=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/cn.search.min.8d45e130fd4c0db67414daf87640a1178f4db2612dc2ec10408eb474a34b4c25.js integrity="sha256-jUXhMP1MDbZ0FNr4dkChF49NsmEtwuwQQI60dKNLTCU=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><link rel=stylesheet href=/css/syntax.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo><span>秋河落叶</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><p>🦉 集中起来的意志可以击穿顽石。</p><hr><ul><li><p><a href=/><strong>🏠 首页</strong></a></p></li><li><p><strong>📌 置顶文章</strong></p><ul><li><a href=/git/common-usage/>Git 常用</a></li><li><a href=/kubernetes/kubeadm-install-k8s-docker/>安装 Kubernetes (Docker)</a></li></ul></li><li><p><strong>📌 置顶分类</strong></p><ul><li><a href=/go/>Golang 编程</a></li><li><a href=/kubernetes/>Kubernetes</a></li><li><a href=/rust/>Rust 编程</a></li><li><a href=/git/>Git</a></li></ul></li></ul><hr><ul><li><strong>🗃️ 开源项目</strong><ul><li><a href=https://github.com/ketches/registry-proxy>registry-proxy</a></li><li><a href=https://github.com/poneding/mdi>mdi</a></li></ul></li></ul><hr><ul><li><a href=https://github.com/poneding target=_blank rel=noopener>🐙 GitHub</a></li><li><a href=mailto:poneding@gmail.com target=_blank rel=noopener>📬 邮箱</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Pod Understood</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#pod-介绍>Pod 介绍</a></li><li><a href=#pod-创建>Pod 创建</a></li><li><a href=#pod-字段>Pod 字段</a><ul><li><a href=#imagepullpolicy>imagePullPolicy</a></li><li><a href=#restartpolicy>restartPolicy</a></li><li><a href=#nodeselector>nodeSelector</a></li><li><a href=#livenessprobe>livenessProbe</a></li><li><a href=#readinessprobe>readinessProbe</a></li><li><a href=#command>command</a></li><li><a href=#args>args</a></li><li><a href=#env>env</a></li><li><a href=#resource>resource</a></li></ul></li><li><a href=#pod-日志>Pod 日志</a></li></ul></nav></aside></header><article class="markdown book-article"><p><a href=/>🏠 首页</a> /
<a href=/kubernetes/>Kubernetes</a> / Kubernetes 0-1 了解 Pod</p><h1 id=kubernetes-0-1-了解-pod>Kubernetes 0-1 了解 Pod
<a class=anchor href=#kubernetes-0-1-%e4%ba%86%e8%a7%a3-pod>#</a></h1><h2 id=pod-介绍>Pod 介绍
<a class=anchor href=#pod-%e4%bb%8b%e7%bb%8d>#</a></h2><p>Pod，是 K8s 对象模型中的最小单元，Pod 里面包含着一组容器（单个容器或多个紧密耦合的容器），这时候 Pod 可以理解为一个机器，而 Pod 里面的容器则理解为该机器里面的进程。</p><p>Pod 的容器运行时由容器引擎提供，默认的容器引擎是 <code>Docker</code>；并且 K8s 管理的是 Pod，而不是容器。</p><p>一个 Pod 内部的容器共享：</p><ul><li>存储：一个 Pod 可以指定一组共享存储卷。</li><li>网络：每个 Pod 分配一个唯一 IP（集群内 IP），共享网络命名空间，包括 IP 地址和网络端口。Pod 内的容器可以使用 localhost 互相通信，集群内 Pod 与 Pod通信可以使用 Pod 分配的 IP，但是由于 Pod 的 IP 是随机分配的，这种互通信的方式不太适合使用。</li></ul><p>尽管一个 Pod 内可以包含多个 Pod，但我们在部署应用容器时的<strong>最佳实践</strong>是一个 Pod 里面只包含一个应用容器作为主容器，其他容器为主容器服务，称之为辅助容器。例如主容器崩溃了，会有一个辅助容器去重启主容器。辅助容器可以有也可以没有，因为 Pod 里面容器的生命周期可以被 Pod 的生命周期取代，而 Pod 的生命周期可以通过 Pod 管理器来管理维护。</p><p>将我们应用服务隔离单独部署在 Pod 的好处可以罗列以下：</p><ul><li>Pod 可以分别的调度到各个 K8s 节点，充分利用了节点的计算资源；</li><li>方便我们单独为某个应用服务做扩缩操作。</li></ul><h2 id=pod-创建>Pod 创建
<a class=anchor href=#pod-%e5%88%9b%e5%bb%ba>#</a></h2><p>在K8s集群中一般不会直接单独创建 Pod，而是通过 Pod 管理器。如果单独创建 Pod，Pod的进程被结束的话，Pod 就永远被删除；使用 Pod 管理器创建出来的Pod，Pod 管理器会负责保证Pod按期调度，即使 Pod 被删除，也会重新被调度起来。简而言之，Pod 的生存由 Pod 管理器全权负责。</p><p>Pod 管理器包含很多种，由很早的 <code>ReplicationController</code> 过渡到 <code>ReplicaSet</code> 再过渡到当前普遍使用的 <code>Deployment</code>，其实这三者能做的事情是类似的，都是调度和监视 Pod 列表，保证 Pod 列表与声明的数量和其他期望相符。</p><p>除此之外还有其他的管理器：</p><ul><li>StatefuleSet：带状态的 Pod 管理器，需要持久存储数据，一般用于创建数据库类型的应用实例，如 mysql，redis；</li><li>DaemonSet：每个符合条件的Node都分配一个 Pod，一般用于创建 agent 服务，如日志收集组件，指标数据收集组件等。</li></ul><p>一般通过以下方式创建 Pod</p><ul><li>单行命令创建 Pod</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl run nginx --image<span class=o>=</span>nginx:latest --replicas<span class=o>=</span><span class=m>2</span>
</span></span></code></pre></div><p>以上命令实际上是创建了一个 Deployment 资源和由其管理的 2 个 Pod。</p><ul><li>定义资源清单，创建 Pod</li></ul><p>以yaml或者json格式定义 Pod 资源，大都选择 yaml。如果你使用VSCode的话，那么 <code>Kubernetes Support</code> 插件会成为你的利器。</p><p>我们先定义个一个 Pod 的资源文件 pod-sample.yaml：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>imagePullPolicy</span><span class=p>:</span><span class=w> </span><span class=l>Always</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>restartPolicy</span><span class=p>:</span><span class=w> </span><span class=l>Never</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;128Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>以上是一个简单的Pod定义文件，我们可以从这个文件得到这些信息：</p><ul><li>运行nginx镜像，作为Pod的主容器，向外暴露80端口；</li><li>每次启动这个Pod都会从网络拉取镜像；</li><li>如果主容器不小心挂了，则不会被重启；</li><li>容器启动需要的最小资源和运行最大资源。</li></ul><p>然后通过 <code>kubectl</code> 命令创建（下面这行命令也适用于更新 Pod）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f pod-sample.yaml
</span></span></code></pre></div><p>查看Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pod -o wide
</span></span></code></pre></div><p>通过查看 Pod 的描述、Pod 里面容器的运行日志，或直接进入 Pod 容器分析定位问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 描述 Pod 详情</span>
</span></span><span class=line><span class=cl>kubectl describe pod &lt;POD_NAME&gt;
</span></span><span class=line><span class=cl><span class=c1># 查看 Pod 容器控制台运行日志</span>
</span></span><span class=line><span class=cl>kubectl logs &lt;POD_NAME&gt;
</span></span><span class=line><span class=cl><span class=c1># 进入 Pod</span>
</span></span><span class=line><span class=cl>kubectl <span class=nb>exec</span> -it &lt;POD_NAME&gt; -c &lt;CONTAINER_NAME&gt; -- &lt;COMMAND&gt;
</span></span></code></pre></div><p>删除 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl delete -f pod-sample.yaml
</span></span><span class=line><span class=cl>kubectl delete pod &lt;POD_NAME&gt;
</span></span></code></pre></div><h2 id=pod-字段>Pod 字段
<a class=anchor href=#pod-%e5%ad%97%e6%ae%b5>#</a></h2><p>通过以下命令查看定义 Pod 资源的字段即作用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl explain pod
</span></span><span class=line><span class=cl>kubectl explain pod.spec
</span></span></code></pre></div><p>对一些字段简单介绍一下：</p><h3 id=imagepullpolicy>imagePullPolicy
<a class=anchor href=#imagepullpolicy>#</a></h3><p>镜像拉取策略，有三种，Always、IfNotPresent、Never</p><ul><li>Always：每次都拉取最新镜像，默认策略；</li><li>IfNotPresent：如果 Pod 被调度的Node上已经存在镜像了则直接使用镜像，不存在在拉取；</li><li>Never：只使用 Node 上的镜像，即使不存在也不拉取。</li></ul><h3 id=restartpolicy>restartPolicy
<a class=anchor href=#restartpolicy>#</a></h3><p>Pod 重启策略，有三种：Always、OnFaliure、Never</p><ul><li>Always：Pod 只要终止运行，kubelet 就会重启它；</li><li>OnFaliure：Pod非正常终止，退出码不为零，kubelet 就会重启它，正常退出不会重启；</li><li>Never：退出了就不重启。</li></ul><h3 id=nodeselector>nodeSelector
<a class=anchor href=#nodeselector>#</a></h3><p>定义Lable对，选择调度到拥有该 Label 对的 Node 节点。</p><h3 id=livenessprobe>livenessProbe
<a class=anchor href=#livenessprobe>#</a></h3><p>存活指针，可以理解为 Pod 内容器运行的健康检查，如果健康检查没通过，则重启 Pod 内容器，这里面的内容有点多，有机会详细讲。</p><h3 id=readinessprobe>readinessProbe
<a class=anchor href=#readinessprobe>#</a></h3><p>就绪指针，也是通过健康检查机制，对外呈现 Pod 的就绪状态，如果健康检查通过，Pod 状态为就绪，可以接受外部流量请求。流量无法转发到非就绪状态的 Pod。</p><h3 id=command>command
<a class=anchor href=#command>#</a></h3><p>容器启动时的命令列表，和 Dockerfile 中定义的 CMD 作用一样。</p><h3 id=args>args
<a class=anchor href=#args>#</a></h3><p>容器启动命令的参数。</p><h3 id=env>env
<a class=anchor href=#env>#</a></h3><p>容器内的环境变量列表，和 Dockerfile 中定义的 ENV 作用一样。</p><h3 id=resource>resource
<a class=anchor href=#resource>#</a></h3><p>可以定义容器启动的最小字段和运行最大分配资源，对 Pod 的资源使用的控制。</p><h2 id=pod-日志>Pod 日志
<a class=anchor href=#pod-%e6%97%a5%e5%bf%97>#</a></h2><p>kubelet 定义了 pod 的日志路径，宿主机目录：</p><pre tabindex=0><code>/var/log/pods/&lt;pod-namespace&gt;_&lt;pod-name&gt;_&lt;pod-uid&gt;/&lt;contianer name&gt;/&lt;restart count&gt;.log
</code></pre><p>日志文件名为 0.log，1.log&mldr;，这里数字使用的是容器重启的次数。</p><hr><p><a href=/kubernetes/nfs-as-pvc/>« 使用 nfs 持久化存储</a></p><p><a href=/kubernetes/prgramming-kubernetes/>» Kubernetes 编程</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/poneding/blog/commit/5faa4f1be5d4525c49e513962394eae7c15fb6f2 title='最后修改者 poneding | 2024/06/13' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2024/06/13</span></a></div><div><a class="flex align-center" href=https://github.com/poneding/blog/edit/master/content/kubernetes/pod-understood.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=poneding/blog data-repo-id=R_kgDOMITIHg data-category=General data-category-id=DIC_kwDOMITIHs4CgB4x data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#pod-介绍>Pod 介绍</a></li><li><a href=#pod-创建>Pod 创建</a></li><li><a href=#pod-字段>Pod 字段</a><ul><li><a href=#imagepullpolicy>imagePullPolicy</a></li><li><a href=#restartpolicy>restartPolicy</a></li><li><a href=#nodeselector>nodeSelector</a></li><li><a href=#livenessprobe>livenessProbe</a></li><li><a href=#readinessprobe>readinessProbe</a></li><li><a href=#command>command</a></li><li><a href=#args>args</a></li><li><a href=#env>env</a></li><li><a href=#resource>resource</a></li></ul></li><li><a href=#pod-日志>Pod 日志</a></li></ul></nav></div></aside></main></body></html>