<!doctype html><html lang=cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="我的博客 / Kubernetes / 了解 Secret
了解 Secret # 通常我们的应用程序的配置都会包含一些敏感信息，例如数据库连接字符串，证书，私钥等，为了保证其安全性，K8s 提供了 Secret 资源对象来保存敏感数据，它和 CongfigMap 类似，也是键值对的映射，并且使用方式也几乎一样。
介绍 Secret # Secret 中存储着键值对数据，可以
作为环境变量传递给容器 作为文件挂载到容器的 Volume Secret 会存储在 Pod 所调度的节点的内存中，而不是写入磁盘。
Pod 默认生成的 Secret # 每个 Pod 都会被自动挂载一个 Secret 卷，只需要使用 kubectl desribe pod 命令就能看到一个名称类似 default-token-n4q6m 的 Secret，Secret 也是一种 K8s 资源，所以，可以使用 kubectl get secret 或 kubectl describe secret 获取查看。
从上面图例可以看出，Pod 默认生成的 Secret 会包含三个配置项：ca.crt、namespace、token。其实这三个配置项是 Pod 内部安全访问Kubernetes API 服务的所有信息，而在 kubectl describe pod 的时候，你可以看到 Secret 所挂载的具体目录在 /var/run/secrets/kubernetes.io/serviceaccount."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://blog.poneding.com/kubernetes/secret-understood/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="我的博客"><meta property="og:description" content="我的博客 / Kubernetes / 了解 Secret
了解 Secret # 通常我们的应用程序的配置都会包含一些敏感信息，例如数据库连接字符串，证书，私钥等，为了保证其安全性，K8s 提供了 Secret 资源对象来保存敏感数据，它和 CongfigMap 类似，也是键值对的映射，并且使用方式也几乎一样。
介绍 Secret # Secret 中存储着键值对数据，可以
作为环境变量传递给容器 作为文件挂载到容器的 Volume Secret 会存储在 Pod 所调度的节点的内存中，而不是写入磁盘。
Pod 默认生成的 Secret # 每个 Pod 都会被自动挂载一个 Secret 卷，只需要使用 kubectl desribe pod 命令就能看到一个名称类似 default-token-n4q6m 的 Secret，Secret 也是一种 K8s 资源，所以，可以使用 kubectl get secret 或 kubectl describe secret 获取查看。
从上面图例可以看出，Pod 默认生成的 Secret 会包含三个配置项：ca.crt、namespace、token。其实这三个配置项是 Pod 内部安全访问Kubernetes API 服务的所有信息，而在 kubectl describe pod 的时候，你可以看到 Secret 所挂载的具体目录在 /var/run/secrets/kubernetes.io/serviceaccount."><meta property="og:locale" content="cn"><meta property="og:type" content="article"><meta property="article:section" content="kubernetes"><meta property="article:modified_time" content="2024-06-12T20:56:33+08:00"><title>Secret Understood | 我的博客</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/logo.png><link rel=canonical href=https://blog.poneding.com/kubernetes/secret-understood/><link rel=stylesheet href=/book.min.4964903a822a7acb10dac6d1ab524833c97fb5f99b141976bcb8a47d539be9c0.css integrity="sha256-SWSQOoIqessQ2sbRq1JIM8l/tfmbFBl2vLikfVOb6cA=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/cn.search.min.9a4e139e0d8feaf510bf71d73a0aec5d39827736ac52bd00d9005a09fd84a9fc.js integrity="sha256-mk4Tng2P6vUQv3HXOgrsXTmCdzasUr0A2QBaCf2Eqfw=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo><span>我的博客</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=https://github.com/poneding target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Secret Understood</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#介绍-secret>介绍 Secret</a><ul><li><a href=#pod-默认生成的-secret>Pod 默认生成的 Secret</a></li></ul></li><li><a href=#创建-secret>创建 Secret</a><ul><li><a href=#单行命令创建-secret>单行命令创建 Secret</a></li><li><a href=#基于资源清单文件创建-secret>基于资源清单文件创建 Secret</a></li></ul></li><li><a href=#使用-secret>使用 Secret</a><ul><li><a href=#使用-secret-作为容器的环境变量>使用 Secret 作为容器的环境变量</a></li><li><a href=#使用-secret-为容器的-volume-提供文件>使用 Secret 为容器的 Volume 提供文件</a></li><li><a href=#使用-secret-拉取私有镜像>使用 Secret 拉取私有镜像</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p><a href=/>我的博客</a> /
<a href=/kubernetes/>Kubernetes</a> / 了解 Secret</p><h1 id=了解-secret>了解 Secret
<a class=anchor href=#%e4%ba%86%e8%a7%a3-secret>#</a></h1><p>通常我们的应用程序的配置都会包含一些敏感信息，例如数据库连接字符串，证书，私钥等，为了保证其安全性，K8s 提供了 Secret 资源对象来保存敏感数据，它和 CongfigMap 类似，也是键值对的映射，并且使用方式也几乎一样。</p><h2 id=介绍-secret>介绍 Secret
<a class=anchor href=#%e4%bb%8b%e7%bb%8d-secret>#</a></h2><p>Secret 中存储着键值对数据，可以</p><ul><li>作为环境变量传递给容器</li><li>作为文件挂载到容器的 Volume</li></ul><p>Secret 会存储在 Pod 所调度的节点的内存中，而不是写入磁盘。</p><h3 id=pod-默认生成的-secret>Pod 默认生成的 Secret
<a class=anchor href=#pod-%e9%bb%98%e8%ae%a4%e7%94%9f%e6%88%90%e7%9a%84-secret>#</a></h3><p>每个 Pod 都会被自动挂载一个 Secret 卷，只需要使用 <code>kubectl desribe pod</code> 命令就能看到一个名称类似 <code>default-token-n4q6m</code> 的 Secret，Secret 也是一种 K8s 资源，所以，可以使用 <code>kubectl get secret</code> 或 <code>kubectl describe secret</code> 获取查看。</p><p><img src=https://fs.poneding.com/images/image-20200708223709295.png alt=image-20200708223709295></p><p><img src=https://fs.poneding.com/images/image-20200708224201615.png alt=image-20200708224201615></p><p>从上面图例可以看出，Pod 默认生成的 Secret 会包含三个配置项：ca.crt、namespace、token。其实这三个配置项是 Pod 内部安全访问Kubernetes API 服务的所有信息，而在 <code>kubectl describe pod</code> 的时候，你可以看到 Secret 所挂载的具体目录在 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>.</p><p><img src=https://fs.poneding.com/images/image-20200708225251762.png alt=image-20200708225251762></p><p>每个 Pod 会默认生成 <code>default-token-xxxxx</code> 的 Secret，可以通过在Pod 中定义 <code>pod.spec.automountServiceAccountToken</code> 为 false 来关闭这种默认行为。</p><h2 id=创建-secret>创建 Secret
<a class=anchor href=#%e5%88%9b%e5%bb%ba-secret>#</a></h2><p>可以直接通过 <code>kubectl create secret</code> 命令创建，也可以先编写 secret 的 yaml 文件再使用 <code>kubectl apply -f &lt;filename></code> 创建，推荐使用后者。</p><h3 id=单行命令创建-secret>单行命令创建 Secret
<a class=anchor href=#%e5%8d%95%e8%a1%8c%e5%91%bd%e4%bb%a4%e5%88%9b%e5%bb%ba-secret>#</a></h3><ul><li>创建一个键值对的 secret：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic first-secret --from-literal<span style=color:#f92672>=</span>user<span style=color:#f92672>=</span>admin --from-literal<span style=color:#f92672>=</span>password<span style=color:#f92672>=</span>admin123
</span></span></code></pre></div><p>创建完成之后，使用 <code>kubectl describe secret first-secret</code> 查看，可以看到这个 secret 的键值内容并不会直接打印出来，而是只显示了占用了多少个字节。</p><p><img src=https://fs.poneding.com/images/image-20200717210508133.png alt=image-20200717210508133></p><ul><li>创建一个文件内容的 Secret</li></ul><p>假如我当前有一个配置文件 secret.json，文件内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;User&#34;</span>: <span style=color:#e6db74>&#34;admin&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;Password&#34;</span>: <span style=color:#e6db74>&#34;admin123&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用以下命令创建 Secret：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic second-secret --from-file<span style=color:#f92672>=</span>secret.json
</span></span></code></pre></div><p>创建完成之后，使用 <code>kubectl describe secret second-secret</code> 查看 secret 的键值内容，同样也不会将文件内容显示出来：</p><p><img src=https://fs.poneding.com/images/image-20200717211045935.png alt=image-20200717211045935></p><blockquote><p>默认使用文件名称 secret.json 作为键值对的 key，也可以通过 <code>--from-file=second_secret=app.json</code> 指定 key 为 <code>second_secret</code>；</p><p>可以使用多组 <code>--from-file=&lt;key>=&lt;filename></code> 参数，在 secret 中定义多组文件；</p><p><code>--from-file=</code> 后面可以直接跟某个文件路径，这样会将目录下的所有文件引入到 Secret;</p><p><code>--from-literal</code> 和 <code>--from-file</code> 可以共同使用，键值合并。</p></blockquote><p>删除创建的 <code>first-secret</code> 和 <code>second-secret</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret first-secret
</span></span><span style=display:flex><span>kubectl delete secret second-secret
</span></span></code></pre></div><h3 id=基于资源清单文件创建-secret>基于资源清单文件创建 Secret
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e8%b5%84%e6%ba%90%e6%b8%85%e5%8d%95%e6%96%87%e4%bb%b6%e5%88%9b%e5%bb%ba-secret>#</a></h3><ul><li>创建一个键值对的 Secret：</li></ul><p>首先定义 Secret 的资源文件 first-secret.yaml，定义如下：</p><p>先使用 base64 对 secret 资源文件中要保存的键值编码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#e6db74>&#34;admin&#34;</span> | base64 <span style=color:#75715e># 得到 YWRtaW4K</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;admin123&#34;</span> | base64 <span style=color:#75715e># 得到 YWRtaW4xMjMK</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vim first-secret.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Secret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>first-secret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>user</span>: <span style=color:#e6db74>&#34;YWRtaW4K&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>password</span>: <span style=color:#e6db74>&#34;YWRtaW4xMjMK&#34;</span>
</span></span></code></pre></div><p>使用 <code>kubectl apply</code> 命令创建 Secret 资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f first-secret.yaml
</span></span></code></pre></div><p>创建完成之后，使用 <code>kubectl describe secret first-secret</code> 查看。</p><blockquote><p>可以在 <code>data</code> 下定义多组键值对。</p></blockquote><ul><li>创建一个文件内容的 Secret</li></ul><p>首先定义 Secret 的资源文件 second-secret.yaml，定义如下：</p><p>先使用 base64 对上文中的 secret.json 文件内容编码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#66d9ef>$(</span>cat secret.json<span style=color:#66d9ef>)</span> | base64 <span style=color:#75715e># 得到 eyAiVXNlciI6ICJhZG1pbiIsICJQYXNzd29yZCI6ICJhZG1pbjEyMyIgfQo=</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vim second-secret.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Secret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>second-secret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>secret.json</span>: <span style=color:#ae81ff>eyAiVXNlciI6ICJhZG1pbiIsICJQYXNzd29yZCI6ICJhZG1pbjEyMyIgfQo=</span>
</span></span></code></pre></div><p>使用 <code>kubectl apply</code> 命令创建 Secret 资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f second-secret.yaml
</span></span></code></pre></div><p>创建完成之后，使用 <code>kubectl describe secret second-secret</code> 查看。</p><blockquote><p>可以在 <code>data</code> 下定义多组文件，也可以和键值对一起定义；</p></blockquote><p>删除创建的 <code>first-secret</code> 和 <code>second-secret</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret first-secret
</span></span><span style=display:flex><span>kubectl delete secret second-secret
</span></span></code></pre></div><h2 id=使用-secret>使用 Secret
<a class=anchor href=#%e4%bd%bf%e7%94%a8-secret>#</a></h2><p>Secret 的用途也与 ConfigMap 相差无几：</p><ul><li>使用 Secret 作为容器的环境变量</li><li>使用 Secret 作为 Volume 向容器提供文件</li></ul><h3 id=使用-secret-作为容器的环境变量>使用 Secret 作为容器的环境变量
<a class=anchor href=#%e4%bd%bf%e7%94%a8-secret-%e4%bd%9c%e4%b8%ba%e5%ae%b9%e5%99%a8%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f>#</a></h3><p>假如有一个名为 <code>first-secret</code> 的 Secret，里面包含了一个键为 <code>user</code>，我想将这个 Secret 中 <code>user</code> 键用到我的环境变量 <code>USER_NAME</code> 中，可以使用如下方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>USER_NAME</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>secretKeyRef</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>first-secret</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>key</span>: <span style=color:#ae81ff>user</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>如果有一个名为 <code>second-secret</code> Secret 中包含多个键如 <code>USER_NAME</code>，<code>PASSWORD</code>，我想将这个 Secret 中所有的键都用到我的环境变量中，可以使用如下方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>container</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>&lt;some-image&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>envFrom</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>prefix</span>: <span style=color:#ae81ff>MYSQL_</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>secretRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>second-secret</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>容器将会生成 <code>DB_USER_NAME</code>，<code>DB_PASSWORD</code> 环境变量，<code>prefix</code> 也可以不配置，则直接使用 Secret 的键。</p><p>注意：</p><ul><li><code>secretRef</code> 与上面 <code>secretKeyRef</code> 的区别；</li><li>如果Secret中有一个为 <code>USER-NAME</code> 键，那么将不会生成 <code>MYSQL_USER-NAME</code> 的环境变量，因为<code>MYSQL_USER-NAME</code> 不是一个合法的环境变量名称。</li></ul><h3 id=使用-secret-为容器的-volume-提供文件>使用 Secret 为容器的 Volume 提供文件
<a class=anchor href=#%e4%bd%bf%e7%94%a8-secret-%e4%b8%ba%e5%ae%b9%e5%99%a8%e7%9a%84-volume-%e6%8f%90%e4%be%9b%e6%96%87%e4%bb%b6>#</a></h3><p>上次的文章——《
<a href=/kubernetes/configmap-understood/>了解 ConfigMap</a>》中，使用 ConfigMap 向容器提供文件，这次使用 Secret 来实际使用一下。</p><p>我们现在有一个文件 secret.json 要传递到容器中，文件内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;User&#34;</span>: <span style=color:#e6db74>&#34;admin&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;Password&#34;</span>: <span style=color:#e6db74>&#34;admin123&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建 Secret</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create secret generic mockapi-secret --from-file<span style=color:#f92672>=</span>secret.json
</span></span></code></pre></div><p>定义 mockapi-pod.yaml 文件如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mockapi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mockapi</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>poneding/mockapi:v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/app/mysettings/secret.json</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mockapi-secret</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>subPath</span>: <span style=color:#ae81ff>secret.json</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>:  <span style=color:#ae81ff>mockapi-secret</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>secret</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>secretName</span>: <span style=color:#ae81ff>mockapi-secret</span>
</span></span></code></pre></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f mockapi-pod.yaml
</span></span></code></pre></div><p>一段时间后，可以验证文件是否挂载到容器：</p><p><img src=https://fs.poneding.com/images/image-20200717221306742.png alt=image-20200717221306742></p><p>Yeah！没毛病。</p><h3 id=使用-secret-拉取私有镜像>使用 Secret 拉取私有镜像
<a class=anchor href=#%e4%bd%bf%e7%94%a8-secret-%e6%8b%89%e5%8f%96%e7%a7%81%e6%9c%89%e9%95%9c%e5%83%8f>#</a></h3><p>当我们要访问拉取私有仓库或者私有镜像时，我们需要可能需要使用到 Secret。</p><p>比如我现在将我 docker 仓库中的镜像 mockapi 设置成私有镜像，这是我使用该镜像创建 Pod 是会显示镜像拉取失败的，很明显，我需要登录 docker。</p><ul><li>创建镜像仓库 Secret</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create secret docker-registry docker-hub-secret --docker-username<span style=color:#f92672>=</span>&lt;my_username&gt; --docker-password<span style=color:#f92672>=</span>&lt;my_password&gt;
</span></span></code></pre></div><blockquote><p>私有仓库的话使用 <code>--docker-server</code> 指定；</p><p>更多使用 <code>kubectl create secret docker-registry --help</code> 查看</p></blockquote><ul><li>Pod 中使用 imagePullSecrets:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>imagePullSecrets</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>docker-hub-secret</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mockapi</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>poneding/mockapi:v1</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><ul><li>使用 ServiceAccount</li></ul><p>如果很多镜像都要从私有仓库拉取，那最好将 secret 添加到一个固定的 ServiceAccount 中，一个 ServiceAccount 可以包含多个镜像仓库 Secret：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceAccount</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>:  <span style=color:#ae81ff>docker-service-account</span>
</span></span><span style=display:flex><span><span style=color:#f92672>imagePullSecrets</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>docker-hub-secret</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>harbor-secret</span>
</span></span></code></pre></div><p>这时 Pod 使用 ServiceAccount 即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceAccountName</span>: <span style=color:#ae81ff>docker-service-account</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><hr><p><a href=/kubernetes/pvc-expansion/>« PVC 扩容</a></p><p><a href=/kubernetes/service-understood/>» 了解 Service</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/poneding/blog/commit/d558b4f864a8b9cf1df3c1afab2835a56d2f733c title='最后修改者 poneding | 2024/06/12' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2024/06/12</span></a></div><div><a class="flex align-center" href=https://github.com/poneding/blog/edit/master/content/kubernetes/secret-understood.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=poneding/blog data-repo-id=R_kgDOMITIHg data-category=General data-category-id=DIC_kwDOMITIHs4CgB4x data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#介绍-secret>介绍 Secret</a><ul><li><a href=#pod-默认生成的-secret>Pod 默认生成的 Secret</a></li></ul></li><li><a href=#创建-secret>创建 Secret</a><ul><li><a href=#单行命令创建-secret>单行命令创建 Secret</a></li><li><a href=#基于资源清单文件创建-secret>基于资源清单文件创建 Secret</a></li></ul></li><li><a href=#使用-secret>使用 Secret</a><ul><li><a href=#使用-secret-作为容器的环境变量>使用 Secret 作为容器的环境变量</a></li><li><a href=#使用-secret-为容器的-volume-提供文件>使用 Secret 为容器的 Volume 提供文件</a></li><li><a href=#使用-secret-拉取私有镜像>使用 Secret 拉取私有镜像</a></li></ul></li></ul></nav></div></aside></main></body></html>