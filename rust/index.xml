<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>秋河落叶</title><link>https://blog.pding.top/rust/</link><description>Recent content on 秋河落叶</description><generator>Hugo</generator><language>cn</language><atom:link href="https://blog.pding.top/rust/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://blog.pding.top/rust/01-getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/01-getting-started/</guid><description>🏠 首页 / Rust 编程 / Rust 入门
Rust 入门 # 安装 # Linux &amp;amp; Mac：
curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 一些常用的 Rust 包依赖于 C 代码，因此可能需要额外安装 C 编译器，在 Mac 上通过运行以下命令可以获得 C 编译器：
xcode-select --install Ubuntu 上通过运行以下命令可以获得 C 编译器：
sudo apt install build-essential Windows：
Windows 用户可以在 Rust 官网 下载安装程序。
配置命令补全 # 第一种方式，zsh 添加 rust 插件：
vim ~/.zshrc 找到 plugins 配置位置，追加 rust:
plugins=(... rust) 第二种方式：
查看帮助：
rustup completions --help 以 Ubuntu 为例，创建目录：</description></item><item><title/><link>https://blog.pding.top/rust/02-cargo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/02-cargo/</guid><description>🏠 首页 / Rust 编程 / Cargo 管理工具
Cargo 管理工具 # cargo 是 Rust 的构建系统和包管理器。
配置国内 rsproxy 源 # vim ~/.cargo/config.toml [source.crates-io] replace-with = &amp;#39;rsproxy-sparse&amp;#39; [source.rsproxy] registry = &amp;#34;https://rsproxy.cn/crates.io-index&amp;#34; [source.rsproxy-sparse] registry = &amp;#34;sparse+https://rsproxy.cn/index/&amp;#34; [registries.rsproxy] index = &amp;#34;https://rsproxy.cn/crates.io-index&amp;#34; [net] git-fetch-with-cli = true 创建项目 # cargo new hello-world cd hello-world 可以使用 cargo new --vcs git hello-world 创建项目并初始化 git 仓库，它将自动创建一个 .gitignore 文件。
编译项目 # cargo build # 编译之后将在 target/debug 目录下生成可执行文件 # 可以通过以下命令运行 .</description></item><item><title/><link>https://blog.pding.top/rust/03-vscode-debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/03-vscode-debugging/</guid><description>🏠 首页 / Rust 编程 / VSCode 调试
VSCode 调试 # 1. 安装插件 # CodeLLDB rust-analyzer 2. 配置 # 项目根目录配置 .vscode/launch.json，调试运行时打开 main.rs 文件。
{ &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;configurations&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;lldb&amp;#34;, &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Debug Rust Project&amp;#34;, &amp;#34;cargo&amp;#34;: { &amp;#34;args&amp;#34;: [ &amp;#34;build&amp;#34;, &amp;#34;--target-dir=${fileDirname}/../target&amp;#34;, &amp;#34;--manifest-path=${fileDirname}/../Cargo.toml&amp;#34; ] }, &amp;#34;args&amp;#34;: [], &amp;#34;cwd&amp;#34;: &amp;#34;${workspaceFolder}&amp;#34; }, { &amp;#34;type&amp;#34;: &amp;#34;lldb&amp;#34;, &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Debug Rust Unit Tests&amp;#34;, &amp;#34;cargo&amp;#34;: { &amp;#34;args&amp;#34;: [ &amp;#34;test&amp;#34;, &amp;#34;--no-run&amp;#34;, &amp;#34;--target-dir=${fileDirname}/../target&amp;#34;, &amp;#34;--manifest-path=${fileDirname}/../Cargo.toml&amp;#34; ] }, &amp;#34;args&amp;#34;: [], &amp;#34;cwd&amp;#34;: &amp;#34;${workspaceFolder}&amp;#34; } ] } 支持 Wrokspace 下多 Rust 项目调试。</description></item><item><title/><link>https://blog.pding.top/rust/04-wasm-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/04-wasm-programming/</guid><description>🏠 首页 / Rust 编程 / Rust WASM 编程
Rust WASM 编程 # 1. 初始化项目 # cargo new hello-wasm cd hello-wasm 2. 安装 wasm-pack # cargo install wasm-pack 3. 编写代码 # 编辑 src/main.rs 文件：
// 使用 wasm-bindgen 在 Rust 与 JavaScript 之间通信 extern crate wasm_bindgen; use wasm_bindgen::prelude::*; #[wasm_bindgen] extern { pub fn alert(s: &amp;amp;str); } #[wasm_bindgen] pub fn greet(name: &amp;amp;str){ alert(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;,name)); } 编辑 Cargo.toml 文件：
[package] name = &amp;#34;hello-wasm&amp;#34; version = &amp;#34;0.</description></item><item><title/><link>https://blog.pding.top/rust/rust-pin-unpin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/rust-pin-unpin/</guid><description>🏠 首页 / Rust 编程 / Rust Pin 和 Unpin
Rust Pin 和 Unpin # Pin 和 Unpin 是 Rust 异步编程中的概念，Pin 是一个包裹了指针的结构体。
pub struct Pin&amp;lt;P&amp;gt; { pointer: P, } Rust 中的类型可以分为两类：
类型的值可以在内存中安全的移动：绝大多数的类型（自动实现了 Unpin 特征） 自引用类型 自引用类型示例：
struct SelfRef { val: String, pointer_of_val: *mut String } 其中 pointer_of_val 是指向 val 的裸指针。这时候，如果 val 被移动，那么 pointer_of_val 指向的地址会引起一个 bug 了。
Pin 即为了避免这类情况发生，表示该指针指向的数据不会被移动。Unpin 则相反。
Unpin # 不好意思，Unpin 是一个实打实的特征。
Pin 住的值并没有实现啥我们想象的 Pin 特征，而是实现了 !Unpin 特征。! 表示没有实现某个特征的意思。!</description></item><item><title/><link>https://blog.pding.top/rust/string-str/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.pding.top/rust/string-str/</guid><description>🏠 首页 / Rust 编程 / String 还是 &amp;amp;str
String 还是 &amp;amp;str # 好用的规则：
始终在结构体中使用 String； 函数入参使用 &amp;amp;str，函数出参使用 String； 如果函数出参来源于入参，并且函数中没有改变入参，那么出参使用 &amp;amp;str。 遵循以上的规则，大部分场景你将很好的避开 String &amp;amp;str 使用困难，即使有问题，编译器会告知你问题所在。
« Rust Pin 和 Unpin</description></item></channel></rss>