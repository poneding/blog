<!doctype html><html lang=cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="我的博客 / Kubernetes / 了解 Volume
了解 Volume # 我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。
在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 Volume 的概念来满足这种需求。
Volume 介绍 # 在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。
在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。
容器与 Volume 的简单关系：
Volume 定义 # 定义在 pod.spec.container 属性下：
kind: Pod ... spec: container: ... volumeMounts: - mountPath: <path> name: <volume-name> subPath: <volume-path> volumes: - name: <volume-name> <volume-type>: ... mountPath： 容器内的目录，如果不存在则创建该目录 subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。 Volume 类型 # Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考： https://kubernetes."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://blog.poneding.com/kubernetes/volume-understood/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="我的博客"><meta property="og:description" content="我的博客 / Kubernetes / 了解 Volume
了解 Volume # 我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。
在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 Volume 的概念来满足这种需求。
Volume 介绍 # 在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。
在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。
容器与 Volume 的简单关系：
Volume 定义 # 定义在 pod.spec.container 属性下：
kind: Pod ... spec: container: ... volumeMounts: - mountPath: <path> name: <volume-name> subPath: <volume-path> volumes: - name: <volume-name> <volume-type>: ... mountPath： 容器内的目录，如果不存在则创建该目录 subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。 Volume 类型 # Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考： https://kubernetes."><meta property="og:locale" content="cn"><meta property="og:type" content="article"><meta property="article:section" content="kubernetes"><meta property="article:modified_time" content="2024-06-12T20:56:33+08:00"><title>Volume Understood | 我的博客</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/logo.png><link rel=canonical href=https://blog.poneding.com/kubernetes/volume-understood/><link rel=stylesheet href=/book.min.4964903a822a7acb10dac6d1ab524833c97fb5f99b141976bcb8a47d539be9c0.css integrity="sha256-SWSQOoIqessQ2sbRq1JIM8l/tfmbFBl2vLikfVOb6cA=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/cn.search.min.9a4e139e0d8feaf510bf71d73a0aec5d39827736ac52bd00d9005a09fd84a9fc.js integrity="sha256-mk4Tng2P6vUQv3HXOgrsXTmCdzasUr0A2QBaCf2Eqfw=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo><span>我的博客</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=https://github.com/poneding target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Volume Understood</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#volume-介绍>Volume 介绍</a></li><li><a href=#volume-定义>Volume 定义</a></li><li><a href=#volume-类型>Volume 类型</a><ul><li><a href=#emptydir>emptyDir</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#configmap>configMap</a></li><li><a href=#secret>Secret</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p><a href=/>我的博客</a> /
<a href=/kubernetes/>Kubernetes</a> / 了解 Volume</p><h1 id=了解-volume>了解 Volume
<a class=anchor href=#%e4%ba%86%e8%a7%a3-volume>#</a></h1><p>我们知道容器与容器之间是隔离的，有独立的文件系统。并且存储的文件性质时临时的，当容器被销毁时，容器内的文件一并被清除。</p><p>在 Pod 内可能运行着多个容器，这可能需要容器共享文件。在 K8s 中，抽象除了 <code>Volume</code> 的概念来满足这种需求。</p><h2 id=volume-介绍>Volume 介绍
<a class=anchor href=#volume-%e4%bb%8b%e7%bb%8d>#</a></h2><p>在 Docker 中，也有 Volume 的概念，它是将容器内某文件目录挂载到宿主机的目录。</p><p>在 K8s 中，Volume 供 Pod 内的容器使用，一个容器可以使用多个 Volume，同一 Pod 内的多个容器可以同时使用一个 Volume，实现文件共享，或数据持久存储。</p><p>容器与 Volume 的简单关系：</p><p><img src=https://fs.poneding.com/images/image-20200623123450872.png alt=image-20200623123450872></p><h2 id=volume-定义>Volume 定义
<a class=anchor href=#volume-%e5%ae%9a%e4%b9%89>#</a></h2><p>定义在 <code>pod.spec.container</code> 属性下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>container</span>: 
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>&lt;path&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>&lt;volume-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>subPath</span>: <span style=color:#ae81ff>&lt;volume-path&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>&lt;volume-name&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;volume-type&gt;</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><ul><li>mountPath： 容器内的目录，如果不存在则创建该目录</li><li>subPath：默认会将 mountPath 直接映射到 volume 的根目录，使用 subpath 映射到 volume 特定的目录。</li></ul><h2 id=volume-类型>Volume 类型
<a class=anchor href=#volume-%e7%b1%bb%e5%9e%8b>#</a></h2><p>Volume 有多种类型，有的可以直接在集群中使用，有的则需要第三方服务或云平台的支持。简单罗列几种常见类型，更多了类型参考：
<a href=https://kubernetes.io/zh/docs/concepts/storage/volumes>https://kubernetes.io/zh/docs/concepts/storage/volumes</a></p><h3 id=emptydir>emptyDir
<a class=anchor href=#emptydir>#</a></h3><p>如果指定 Volume 类型为 emptyDir，它会在 Pod 刚被调度时，在被调度到的节点上创建起来。卷初始时时空的，里面没有文件，Pod 内的容器可以在卷中写入文件。多个容器绑定的 Volume 如果存在目录相同，则目录可以被共享读写。</p><p>如果 Pod 在该节点被销毁，那么 emptyDir 也将被永久删除。Pod 内的容器崩溃或重启是不会影响 emptyDir 的生命周期的。</p><p>由于 emptyDir 的生命周期受Pod影响，emptyDir 适合的使用场景也会受限，emptyDir 适合使用在数据临时计算，临时缓存等，不适合存储配置信息或持久化数据。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/shareDir</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/shareDir</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>emptyDir</span>: {}
</span></span></code></pre></div><p>如果在 K8s 中创建上面这个 Pod，容器都运行起来后，分别进入 nginx 容器和 redis 容器，都可以在根目录下看到 <code>shareDir</code> 目录，并且在一个容器中写入了文件，另一个容器也可以读取到。当删除这个 Pod，再重新创建后，之前写入的文件会消失。</p><p>emptyDir 可以指定存储介质，默认是使用节点的磁盘创建起来的，也可以指定介质为内存，这种读写更快：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>emptyDir</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>medium</span>: <span style=color:#ae81ff>Memory</span>
</span></span></code></pre></div><h3 id=hostpath>hostPath
<a class=anchor href=#hostpath>#</a></h3><p>hostPath 卷指向节点文件系统上的特定文件或目录，如果多个 Pod 运行在同一节点，并且指向相同的卷路径，则他们看的文件是相同的。</p><p><img src=https://fs.poneding.com/images/image-20200623145055913.png alt=image-20200623145055913></p><p>hostPath 类型的 Volume 的生命周期不受Pod限制，Pod 被删除，hostPath 下的文件仍然保留。由于 hostPath 数据只会保留在节点上，当 Pod 被重新调度到其他节点时，相对来说数据是丢失的。一般可以使用 hostPath 作为 DaemonSet（每个匹配节点都调度一个 Pod）管理的 Pod 的 Volume。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/data</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>dir</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/vol/redis/data</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>type</span>: <span style=color:#ae81ff>DirectoryOrCreate</span>
</span></span></code></pre></div><p>当我们创建以上 Pod 资源，容器运行起来之后，则会在 Pod 所调度的宿主机上创建 <code>/vol/redis/data</code> 目录。如果我们删除Pod，宿主机上的 <code>/vol/redis/data</code> 目录不会被删除。</p><p>hostPath 的 type 类型，默认为空，直接使用 path，其他 type 使用时会检查和初始化 path：</p><ul><li>DirectoryOrCreate，如果 hostPath 定义的 path 目录不存在，则创建目录</li><li>Directory，hostPath 定义的 path 目录已经存在，否则会异常</li><li>FileOrCreate，如果 hostPath 定义 的path 文件不存在，则创建文件，如果前缀目录不存在也会报错，需要先使用 DirectoryOrCreate 创建目录</li><li>File，hostPath 定义的 path 文件已经存在，否则会异常</li></ul><h3 id=persistentvolumeclaim>persistentVolumeClaim
<a class=anchor href=#persistentvolumeclaim>#</a></h3><h3 id=awselasticblockstore>awsElasticBlockStore
<a class=anchor href=#awselasticblockstore>#</a></h3><p>使用 aws 的存储卷作为 Pod 的 Volume，它可以被多个 Pod 共同使用，并且它的生命周期不受 Pod 限制，当 Pod 被销毁，只是取消了绑定关系，存储不会被删除。</p><p>使用 awsElasticBlockStore 作为 Volume，需要提前在 aws 中创 volume，获取到 volumeID，然后 Pod 的 Volume 指定awsElasticBlockStore 的 volumeID 即可。</p><p>使用 aws-cli 创建 aws 中的 volume：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#f92672>=</span>ap-southeast-1a --size<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> --volume-type<span style=color:#f92672>=</span>gp2
</span></span></code></pre></div><p>以上命令完成会输出 volumeID。</p><p>使用 awsElasticBlockStore 作为 Pod 的 Volume 简单示例，前提我们已经获取到 了volumeID 为 vol-07afc8d24f8f08d2a：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/data</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis-data</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>redis-data</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>awsElasticBlockStore</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeID</span>: <span style=color:#ae81ff>vol-07afc8d24f8f08d2a</span>
</span></span></code></pre></div><p>当我们创建以上 Pod 资源，容器运行起来之后，我们进入 redis 容器，使用 redis-cli往redis 中写入一个key-value后，立即退出容器，删除 Pod 并重新创建后，再次进入容器，是依然可以获取 key-value 的，这说明 Volume 数据没有随 Pod 被删除。</p><h3 id=configmap>configMap
<a class=anchor href=#configmap>#</a></h3><p>存储配置项信息，供 Volume 使用，后续可能会单独介绍它的使用。</p><h3 id=secret>Secret
<a class=anchor href=#secret>#</a></h3><p>存储敏感信息的配置，供 Volume 使用，后续可能会单独介绍它的使用。</p><hr><p><a href=/kubernetes/velero-minio-backup-restore-volume/>« Velero + Minio 备份与恢复</a></p><p><a href=/kubernetes/vpa/>» VPA</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/poneding/blog/commit/d558b4f864a8b9cf1df3c1afab2835a56d2f733c title='最后修改者 poneding | 2024/06/12' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2024/06/12</span></a></div><div><a class="flex align-center" href=https://github.com/poneding/blog/edit/master/content/kubernetes/volume-understood.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=poneding/blog data-repo-id=R_kgDOMITIHg data-category=General data-category-id=DIC_kwDOMITIHs4CgB4x data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#volume-介绍>Volume 介绍</a></li><li><a href=#volume-定义>Volume 定义</a></li><li><a href=#volume-类型>Volume 类型</a><ul><li><a href=#emptydir>emptyDir</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#configmap>configMap</a></li><li><a href=#secret>Secret</a></li></ul></li></ul></nav></div></aside></main></body></html>